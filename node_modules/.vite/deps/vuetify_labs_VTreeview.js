import {
  VCheckboxBtn,
  VList,
  VListGroup,
  VListItem,
  VListItemAction,
  makeFilterProps,
  makeVListGroupProps,
  makeVListItemProps,
  makeVListProps,
  useFilter,
  useListItems,
  useNestedItem
} from "./chunk-2SEYRKHY.js";
import {
  VBtn,
  VDefaultsProvider,
  VProgressCircular
} from "./chunk-CVOVTK2U.js";
import "./chunk-QBBSUQYO.js";
import {
  useLink
} from "./chunk-2FNAEPFH.js";
import {
  IconValue
} from "./chunk-PLTFRTRW.js";
import {
  EventProp,
  genericComponent,
  omit,
  propsFactory,
  provideDefaults,
  useProxiedModel,
  useRender
} from "./chunk-RNU2TQL5.js";
import {
  Fragment,
  computed,
  createVNode,
  inject,
  mergeProps,
  provide,
  ref,
  shallowRef,
  toRaw,
  toRef,
  withModifiers
} from "./chunk-U3LI7FBV.js";
import "./chunk-G3PMV62Z.js";

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewGroup.mjs
var makeVTreeviewGroupProps = propsFactory({
  ...omit(makeVListGroupProps({
    collapseIcon: "$treeviewCollapse",
    expandIcon: "$treeviewExpand"
  }), ["subgroup"])
}, "VTreeviewGroup");
var VTreeviewGroup = genericComponent()({
  name: "VTreeviewGroup",
  props: makeVTreeviewGroupProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const vListGroupRef = ref();
    const toggleIcon = computed(() => {
      var _a;
      return ((_a = vListGroupRef.value) == null ? void 0 : _a.isOpen) ? props.collapseIcon : props.expandIcon;
    });
    const activatorDefaults = computed(() => {
      var _a;
      return {
        VTreeviewItem: {
          prependIcon: void 0,
          appendIcon: void 0,
          active: (_a = vListGroupRef.value) == null ? void 0 : _a.isOpen,
          toggleIcon: toggleIcon.value
        }
      };
    });
    useRender(() => {
      const listGroupProps = VListGroup.filterProps(props);
      return createVNode(VListGroup, mergeProps(listGroupProps, {
        "ref": vListGroupRef,
        "class": ["v-treeview-group", props.class],
        "subgroup": true
      }), {
        ...slots,
        activator: slots.activator ? (slotProps) => createVNode(Fragment, null, [createVNode(VDefaultsProvider, {
          "defaults": activatorDefaults.value
        }, {
          default: () => {
            var _a;
            return [(_a = slots.activator) == null ? void 0 : _a.call(slots, slotProps)];
          }
        })]) : void 0
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewItem.mjs
import "/Users/yanfedro/Desktop/tocifawebdev/node_modules/vuetify/lib/labs/VTreeview/VTreeviewItem.css";

// node_modules/vuetify/lib/labs/VTreeview/shared.mjs
var VTreeviewSymbol = Symbol.for("vuetify:v-treeview");

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewItem.mjs
var makeVTreeviewItemProps = propsFactory({
  loading: Boolean,
  onToggleExpand: EventProp(),
  toggleIcon: IconValue,
  ...makeVListItemProps({
    slim: true
  })
}, "VTreeviewItem");
var VTreeviewItem = genericComponent()({
  name: "VTreeviewItem",
  props: makeVTreeviewItemProps(),
  setup(props, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const link = useLink(props, attrs);
    const rawId = computed(() => props.value === void 0 ? link.href.value : props.value);
    const vListItemRef = ref();
    const {
      activate,
      isActivated,
      isGroupActivator,
      root,
      id
    } = useNestedItem(rawId, false);
    const isActivatableGroupActivator = computed(() => root.activatable.value && isGroupActivator);
    const isClickable = computed(() => {
      var _a;
      return !props.disabled && props.link !== false && (props.link || link.isClickable.value || props.value != null && !!((_a = vListItemRef.value) == null ? void 0 : _a.list) || isActivatableGroupActivator.value);
    });
    function activateItem(e) {
      var _a, _b;
      if (!isClickable.value || !isActivatableGroupActivator.value && isGroupActivator) return;
      if (root.activatable.value) {
        if (isActivatableGroupActivator.value) {
          activate(!isActivated.value, e);
        } else {
          (_b = vListItemRef.value) == null ? void 0 : _b.activate(!((_a = vListItemRef.value) == null ? void 0 : _a.isActivated), e);
        }
      }
    }
    const visibleIds = inject(VTreeviewSymbol, {
      visibleIds: ref()
    }).visibleIds;
    useRender(() => {
      const listItemProps = omit(VListItem.filterProps(props), ["onClick"]);
      const hasPrepend = slots.prepend || props.toggleIcon;
      return createVNode(VListItem, mergeProps(listItemProps, {
        "active": isActivated.value,
        "class": ["v-treeview-item", {
          "v-treeview-item--activatable-group-activator": isActivatableGroupActivator.value,
          "v-treeview-item--filtered": visibleIds.value && !visibleIds.value.has(id.value)
        }, props.class],
        "ripple": false,
        "onClick": props.onClick ?? activateItem
      }), {
        ...slots,
        prepend: hasPrepend ? (slotProps) => {
          var _a;
          return createVNode(Fragment, null, [props.toggleIcon && createVNode(VListItemAction, {
            "start": false
          }, {
            default: () => [createVNode(VBtn, {
              "density": "compact",
              "icon": props.toggleIcon,
              "loading": props.loading,
              "variant": "text",
              "onClick": props.onToggleExpand
            }, {
              loader() {
                return createVNode(VProgressCircular, {
                  "indeterminate": "disable-shrink",
                  "size": "20",
                  "width": "2"
                }, null);
              }
            })]
          }), (_a = slots.prepend) == null ? void 0 : _a.call(slots, slotProps)]);
        } : void 0
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewChildren.mjs
var makeVTreeviewChildrenProps = propsFactory({
  loadChildren: Function,
  loadingIcon: {
    type: String,
    default: "$loading"
  },
  items: Array,
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  falseIcon: IconValue,
  trueIcon: IconValue,
  returnObject: Boolean,
  selectable: Boolean,
  selectedColor: String,
  selectStrategy: [String, Function, Object]
}, "VTreeviewChildren");
var VTreeviewChildren = genericComponent()({
  name: "VTreeviewChildren",
  props: makeVTreeviewChildrenProps(),
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const isLoading = shallowRef(null);
    const isClickOnOpen = computed(() => props.openOnClick != null ? props.openOnClick : props.selectable);
    function checkChildren(item) {
      return new Promise((resolve) => {
        var _a, _b;
        if (!((_a = props.items) == null ? void 0 : _a.length) || !props.loadChildren) return resolve();
        if (((_b = item == null ? void 0 : item.children) == null ? void 0 : _b.length) === 0) {
          isLoading.value = item.value;
          props.loadChildren(item).then(resolve);
          return;
        }
        resolve();
      }).finally(() => {
        isLoading.value = null;
      });
    }
    function selectItem(select, isSelected) {
      if (props.selectable) {
        select(!isSelected);
      }
    }
    return () => {
      var _a, _b;
      return ((_a = slots.default) == null ? void 0 : _a.call(slots)) ?? ((_b = props.items) == null ? void 0 : _b.map((_ref2) => {
        var _a2;
        let {
          children,
          props: itemProps,
          raw: item
        } = _ref2;
        const loading = isLoading.value === item.value;
        const slotsWithItem = {
          prepend: (slotProps) => {
            var _a3;
            return createVNode(Fragment, null, [props.selectable && (!children || children && !["leaf", "single-leaf"].includes(props.selectStrategy)) && createVNode("div", null, [createVNode(VCheckboxBtn, {
              "key": item.value,
              "modelValue": slotProps.isSelected,
              "loading": loading,
              "color": props.selectedColor,
              "indeterminate": slotProps.isIndeterminate,
              "indeterminateIcon": props.indeterminateIcon,
              "falseIcon": props.falseIcon,
              "trueIcon": props.trueIcon,
              "onClick": withModifiers(() => selectItem(slotProps.select, slotProps.isSelected), ["stop"]),
              "onKeydown": (e) => {
                if (!["Enter", "Space"].includes(e.key)) return;
                e.stopPropagation();
                selectItem(slotProps.select, slotProps.isSelected);
              }
            }, null)]), (_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, {
              ...slotProps,
              item
            })]);
          },
          append: slots.append ? (slotProps) => {
            var _a3;
            return (_a3 = slots.append) == null ? void 0 : _a3.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          title: slots.title ? (slotProps) => {
            var _a3;
            return (_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
              ...slotProps,
              item
            });
          } : void 0
        };
        const treeviewGroupProps = VTreeviewGroup.filterProps(itemProps);
        const treeviewChildrenProps = VTreeviewChildren.filterProps(props);
        return children ? createVNode(VTreeviewGroup, mergeProps(treeviewGroupProps, {
          "value": props.returnObject ? item : treeviewGroupProps == null ? void 0 : treeviewGroupProps.value
        }), {
          activator: (_ref3) => {
            let {
              props: activatorProps
            } = _ref3;
            const listItemProps = {
              ...itemProps,
              ...activatorProps,
              value: itemProps == null ? void 0 : itemProps.value,
              onToggleExpand: activatorProps.onClick,
              onClick: isClickOnOpen.value ? [() => checkChildren(item), activatorProps.onClick] : void 0
            };
            return createVNode(VTreeviewItem, mergeProps(listItemProps, {
              "value": props.returnObject ? toRaw(item) : itemProps.value,
              "loading": loading
            }), slotsWithItem);
          },
          default: () => createVNode(VTreeviewChildren, mergeProps(treeviewChildrenProps, {
            "items": children,
            "returnObject": props.returnObject
          }), slots)
        }) : ((_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
          props: itemProps
        })) ?? createVNode(VTreeviewItem, mergeProps(itemProps, {
          "value": props.returnObject ? toRaw(item) : itemProps.value
        }), slotsWithItem);
      }));
    };
  }
});

// node_modules/vuetify/lib/labs/VTreeview/VTreeview.mjs
function flatten(items) {
  let flat = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  for (const item of items) {
    flat.push(item);
    if (item.children) flatten(item.children, flat);
  }
  return flat;
}
var makeVTreeviewProps = propsFactory({
  openAll: Boolean,
  search: String,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeVTreeviewChildrenProps(),
  ...omit(makeVListProps({
    collapseIcon: "$treeviewCollapse",
    expandIcon: "$treeviewExpand",
    slim: true
  }), ["itemType", "nav", "openStrategy"]),
  modelValue: {
    type: Array,
    default: () => []
  }
}, "VTreeview");
var VTreeview = genericComponent()({
  name: "VTreeview",
  props: makeVTreeviewProps(),
  emits: {
    "update:opened": (val) => true,
    "update:activated": (val) => true,
    "update:selected": (val) => true,
    "update:modelValue": (val) => true,
    "click:open": (value) => true,
    "click:select": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      items
    } = useListItems(props);
    const activeColor = toRef(props, "activeColor");
    const baseColor = toRef(props, "baseColor");
    const color = toRef(props, "color");
    const activated = useProxiedModel(props, "activated");
    const model = useProxiedModel(props, "modelValue");
    const _selected = useProxiedModel(props, "selected", props.modelValue);
    const selected = computed({
      get: () => _selected.value,
      set(val) {
        _selected.value = val;
        model.value = val;
      }
    });
    const vListRef = ref();
    const opened = computed(() => props.openAll ? openAll(items.value) : props.opened);
    const flatItems = computed(() => flatten(items.value));
    const search = toRef(props, "search");
    const {
      filteredItems
    } = useFilter(props, flatItems, search);
    const visibleIds = computed(() => {
      if (!search.value) {
        return null;
      }
      return new Set(filteredItems.value.flatMap((item) => {
        return [...getPath(item.props.value), ...getChildren(item.props.value)];
      }));
    });
    function getPath(id) {
      var _a;
      const path = [];
      let parent = id;
      while (parent != null) {
        path.unshift(parent);
        parent = (_a = vListRef.value) == null ? void 0 : _a.parents.get(parent);
      }
      return path;
    }
    function getChildren(id) {
      var _a, _b;
      const arr = [];
      const queue = (((_a = vListRef.value) == null ? void 0 : _a.children.get(id)) ?? []).slice();
      while (queue.length) {
        const child = queue.shift();
        if (!child) continue;
        arr.push(child);
        queue.push(...(((_b = vListRef.value) == null ? void 0 : _b.children.get(child)) ?? []).slice());
      }
      return arr;
    }
    function openAll(items2) {
      let ids = [];
      for (const i of items2) {
        if (!i.children) continue;
        ids.push(props.returnObject ? toRaw(i.raw) : i.value);
        if (i.children) {
          ids = ids.concat(openAll(i.children));
        }
      }
      return ids;
    }
    provide(VTreeviewSymbol, {
      visibleIds
    });
    provideDefaults({
      VTreeviewGroup: {
        activeColor,
        baseColor,
        color,
        collapseIcon: toRef(props, "collapseIcon"),
        expandIcon: toRef(props, "expandIcon")
      },
      VTreeviewItem: {
        activeClass: toRef(props, "activeClass"),
        activeColor,
        baseColor,
        color,
        density: toRef(props, "density"),
        disabled: toRef(props, "disabled"),
        lines: toRef(props, "lines"),
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      const listProps = VList.filterProps(props);
      const treeviewChildrenProps = VTreeviewChildren.filterProps(props);
      return createVNode(VList, mergeProps({
        "ref": vListRef
      }, listProps, {
        "class": ["v-treeview", props.class],
        "open-strategy": "multiple",
        "style": props.style,
        "opened": opened.value,
        "activated": activated.value,
        "onUpdate:activated": ($event) => activated.value = $event,
        "selected": selected.value,
        "onUpdate:selected": ($event) => selected.value = $event
      }), {
        default: () => [createVNode(VTreeviewChildren, mergeProps(treeviewChildrenProps, {
          "returnObject": props.returnObject,
          "items": items.value
        }), slots)]
      });
    });
    return {};
  }
});
export {
  VTreeview,
  VTreeviewGroup,
  VTreeviewItem
};
//# sourceMappingURL=vuetify_labs_VTreeview.js.map
